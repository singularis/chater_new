default_prompt: |
  Analyse a single photo and respond exclusively with a valid JSON object—no extra text, comments, or code fences. 
  Keys must appear precisely in the order shown below, and all numeric outputs must be whole integers without units.
  If the main subject **is** food or drink (including packaged items such as a Coca‑Cola can, wrapped candy bar, or bottled drinks)
  First, decide if the main subject is edible. If it is not food or drink, return:
  {
  "error": "NOT A FOOD"
  }
  If it is food or drink, return:
  {
  "type": "food_processing",
  "dish_name": "<probable dish name>",
  "estimated_avg_calories": <integer>,
  "ingredients": ["<ingredient1>", "..."],
  "total_avg_weight": <integer>,
  "contains": {
  "proteins": <integer>,
  "fats": <integer>,
  "carbohydrates": <integer>,
  "sugar": <integer>,
  "is_alcohol": <boolean>
  }
  }
  Additional rules:
  Base calorie and macronutrient estimates on typical serving sizes from reliable nutritional references, assuming worst-case values (full-fat ingredients, all cooking oil absorbed, and all dressings or sauces fully consumed).
  Calorie and macro values must reflect a realistic scenario: full-fat ingredients, all oils absorbed, and sauces fully consumed. Use reliable nutritional references (USDA, NCCDB, McCance & Widdowson, etc.).
  Keys must appear precisely in the order shown. Do not include special characters like @, #, $, %, ^, &, *, (, ), [, ], {, }, |, \, ' in the response, food names, ingredients, etc
  Nutritional Logic:
  Base all estimates on reliable nutritional references (e.g., USDA FoodData Central, NCCDB).
  Assume a "worst-case" nutritional scenario: use full-fat and full-sugar ingredients, assume all cooking oil is absorbed, and that all visible dressings or sauces are consumed.
  Portion Size Estimation Hierarchy:
  Estimate weight and portion size using the following methods in order of priority:
  Known Volume/Weight: If the item is a packaged product with a visible label (e.g., "330ml can," "50g chocolate bar"), use that as the primary source for its weight.
  Visible Reference Objects: If visible, compare the food's size to everyday objects. Use the following standard dimensions: dinner plate (≈approximately 28 cm), dinner fork (≈approximately 19 cm), human hand (width ≈approximately 9 cm), and credit card (≈approximately 8.5 cm).
  Implied Culinary Standards: If no reference object is visible, estimate based on typical culinary standards for the identified dish (e.g., a standard single-serving pizza is ~250-350g, a restaurant steak serving is ~225g, a can of soda is 330g).
  Formatting and Character Rules:
  Numeric Values: Round every numeric value to the nearest whole number. Return as a plain integer without any units (e.g., "g" or "kcal"). The keys `total_avg_weight_g` and `contains_g` are named to clarify the unit without including it in the value.
  String Content: All strings (`dish_name` and `ingredients`) must only contain lowercase alphanumeric characters (a-z, 0-9) and spaces. Capitalize first letter of first word of dish_name and ingredients. Remove all other characters, such as punctuation, hyphens, or symbols.
  Spelling: Ensure all food and ingredient names are spelt correctly before applying formatting rules.
  Round every numeric value to the nearest whole number, return as plain integers with no “g” or “kcal” suffixes.
  If the item is an alcoholic drink (beer, wine, spirits, cocktails, hard seltzer, etc.), set is_alcohol to true; otherwise set to false.
weight_prompt: |
  You receive the raw text returned by Google Cloud Vision for a photo of a weight scale. Extract a valid weight value in kilograms and reply only with JSON with no additional text.
  rules:
    The OCR may omit commas or decimal dots for example 753 could mean 75.3 Normalize any separator to a dot. If none is present treat the last digit as the decimal
    Acceptable weights are from 30 to 150 kilograms and you responce should in this range
    if weight is not in this range, respond with invalid_weight json structure
    Output exactly one of these JSON structures
  json_examples:
    valid_weight:
      type: weight_processing
      weight: numeric_value
    invalid_weight:
      error: INVALID_WEIGHT
get_recommendation: |
  You are a deterministic JSON generator. Do not explain.
  - Identify which foods are generally healthier and should be consumed more.
  - Identify which foods should be reduced or avoided for better health.
  - Respond only by JSON. No additional text.
  - For JSON response, send only keys and values.
  - Response should include 4 main fields in following order. Do not change order of fields in response:
  - 1) foods_to_reduce_or_avoid(dish_name, reason) provide 3 most harmful options
  - 2) healthier_foods(dish_name, reason) provide 3 most healthier options
  - 3) general_recommendations(key:value) 3 most important recommendation (6 words to 20 words)
  - 4) translation_keys: Provide a mapping of English keys to target language translations
  
  CRITICAL TRANSLATION REQUIREMENT
  - You MUST translate ALL values to the target language specified in "respond_in_language"
  - DO NOT leave any values in English or other languages
  - EVERY dish_name, reason, and recommendation value must be in the target language
  - If you cannot translate to the target language, use a similar language you know well
  - The translation_keys section is MANDATORY and must contain proper translations
  
  EXAMPLE OUTPUT STRUCTURE (for Ukrainian target language):
  {
    "foods_to_reduce_or_avoid": [
      {"dish_name": "Піца", "reason": "Високий вміст калорій та жирів"},
      {"dish_name": "Гамбургер", "reason": "Багато насичених жирів"}
    ],
    "healthier_foods": [
      {"dish_name": "Салат", "reason": "Багато вітамінів та мінералів"}
    ],
    "general_recommendations": {
      "protein": "Споживайте більше білків",
      "fiber": "Додайте більше клітковини"
    },
    "translation_keys": {
      "foods_to_reduce_or_avoid": "Продукти для зменшення або уникнення",
      "healthier_foods": "Більш здорові продукти",
      "general_recommendations": "Загальні рекомендації"
    }
  }
  
  - IMPORTANT: Use the exact JSON keys provided above, but translate all values to the target language.
  - The translation_keys section should map English keys to their natural translations in the target language.
respond_in_language: |
  When generating any textual output fields, respond in the specified target language code provided as "respond_in_language" (ISO 639-1, e.g., en, fr). If not provided or unsupported, default to English (en). 
  
  CRITICAL LOCALIZATION RULES - FOLLOW EXACTLY
  1. Keep JSON keys in English (e.g., "foods_to_reduce_or_avoid", "healthier_foods", "general_recommendations")
  2. TRANSLATE ALL VALUES TO THE TARGET LANGUAGE - NO EXCEPTIONS:
     - dish_name values → MUST be in target language
     - reason values → MUST be in target language  
     - general_recommendations values → MUST be in target language
     - ALL other text values → MUST be in target language
  3. Maintain the exact JSON structure with English keys
  4. Ensure all translated text is properly formatted and natural in the target language
  5. Add a "translation_keys" section that maps English keys to target language translations
  6. NEVER leave any content in English or other languages - ONLY the target language
  7. If unsure about translation, use the most appropriate equivalent in the target language
   COMMON MISTAKES TO AVOID:
  - DO NOT leave dish names in English (e.g., "Pizza" instead of "Піца")
  - DO NOT leave reasons in English (e.g., "High in calories" instead of "Високий вміст калорій")
  - DO NOT leave recommendations in English (e.g., "Eat more protein" instead of "Споживайте більше білків")
  - DO NOT mix languages in the same response
  - DO NOT skip the translation_keys section
  CORRECT APPROACH:
  - Translate EVERY text value to the target language
  - Use proper grammar and natural phrasing in the target language
  - Ensure cultural appropriateness for the target language
  - Provide complete translation_keys mapping
get_recommendation_local: |
  JSON ONLY. No explanation. Keep output short.
  Keys and order (exactly 4 items). Do not change order of fields in response JSON ONLY RESPONSE SHOULD BE IN THIS FORMAT:
  1) foods_to_reduce_or_avoid: list of 3 objects {dish_name, reason}
  2) healthier_foods: list of 3 objects {dish_name, reason}.
  3) general_recommendations: object with 3 short values (6–12 words each)
  4) translation_keys: map English keys to target language labels for the three sections

  Rules:
  - Translate ALL values to the target language.
  - Dish names concise; reasons brief and specific.
  - Output MUST be a single top-level JSON object, not wrapped in {"key":..., "value":{...}}.
  - Use EXACT key names above; do NOT use synonyms like "healthy_alternatives" or "translation_notes".
  - No extra top-level fields (e.g., "user_email", "key", "value").
  - Exactly 3 items in each list, no more, no less.
  - No markdown, no comments, no trailing text.
  - Be deterministic and consistent.